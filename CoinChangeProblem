package dp;

/**
 * Unbounded knapsack
 * Given an integer array of coins[] of size n representing different types of
 * denominations and an integer sum, the task is to count all combinations of
 * coins to make a given value sum.
 * 
 * Note: Assume that you have an infinite supply of each type of coin.
 * 
 * Examples:
 * 
 * Input: sum = 4, coins[] = [1, 2, 3] Output: 4 Explanation: There are four
 * solutions: [1, 1, 1, 1], [1, 1, 2], [2, 2] and [1, 3]
 * 
 * Input: sum = 10, coins[] = [2, 5, 3, 6] Output: 5 Explanation: There are five
 * solutions: [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5] and [5, 5]
 * 
 * Input: sum = 10, coins[] = [10]
 */
class CoinChangeProblem {

	Integer dp[][];

	public int coinChange(int[] coins, int amount) {

		int n = coins.length;
		dp = new Integer[n + 1][amount + 1];

		return find(coins, amount, n, 0);
	}

	int find(int[] coins, int amount, int n, int count) {
		if (n == 0 && amount > 0) {
			return 0;
		}

		if (amount == 0) {
			return 1;
		}

		if (dp[n][amount] != null) {
			return dp[n][amount];
		}

		if (coins[n - 1] <= amount) {
			return dp[n][amount] = find(coins, amount - coins[n - 1], n, count + 1) + find(coins, amount, n - 1, count);
		} else {
			return dp[n][amount] = find(coins, amount, n - 1, count);
		}
	}
}
